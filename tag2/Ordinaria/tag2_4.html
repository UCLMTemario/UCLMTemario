<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Aika Kenshi" />
  <title>Entrega de servicios</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Entrega de servicios</h1>
<p class="subtitle">TEMA 4</p>
<p class="author">Aika Kenshi</p>
<p class="date">10-12-2024</p>
</header>
<h1 id="de-la-metodología-en-cascada-a-ágil">De la metodología en
cascada a ágil</h1>
<h2 id="ciclo-de-vida-en-cascada">Ciclo de vida en cascada</h2>
<ol type="1">
<li><p>Requisitos del sistema.</p></li>
<li><p>Requisitos software.</p></li>
<li><p>Análisis.</p></li>
<li><p>Diseño del programa.</p></li>
<li><p>Codificación.</p></li>
<li><p>Testing.</p></li>
<li><p>Operaciones.</p></li>
</ol>
<h2 id="ciclo-de-vida-en-v">Ciclo de vida en V</h2>
<p>Relación entre las actividades de prueba con el análisis y el
diseño.</p>
<ul>
<li>Variación del modelo en cascada.</li>
</ul>
<h2 id="por-qué-fallaron">¿Por qué fallaron?</h2>
<ul>
<li><p>Los proyectos se enfrentaban a cientos de requisitos.</p></li>
<li><p>La documentación se convertía en un fin y no cumplía con su
objetivo.</p></li>
<li><p>Implementaciones sin supervisión de los clientes.</p></li>
</ul>
<h2 id="inicios-de-las-metodologías-ágiles">Inicios de las metodologías
ágiles</h2>
<h3 id="extreme-programming">eXtreme Programming</h3>
<ul>
<li><p>Más énfasis en la adaptabilidad que en la previsibilidad (cambios
de requisitos sobre la marcha son acciones naturales e
inevitables).</p></li>
<li><p>4 variables: coste, tiempo, calidad y alcance.</p></li>
<li><p>5 valores: comunicación, simplicidad, feedback, respeto y
valentía.</p></li>
<li><p>Plazos temporales basándonos en exigencias del cliente.</p></li>
<li><p>Entrega de software útil en cada uno de estos plazos.</p></li>
<li><p>Continuamente se han de efectuar una serie de pruebas
automatizadas en base a los requisitos del cliente.</p></li>
<li><p>Diseño del programa suele ser simple y basado en la funcionalidad
del sistema.</p></li>
<li><p>Programación por pares.</p></li>
<li><p>Cualquiera puede añadir y retocar parte del código, aunque eso
sí, deba ser un estilo común.</p></li>
</ul>
<h2 id="manifiesto-ágil">Manifiesto ágil</h2>
<ul>
<li><p>17 críticos de los modelos de mejora de desarrollo de software
basados en procesos convocados por Kent Beck.</p></li>
<li><p>Métodos ágiles: métodos que estaban surgiendo como alternativa a
las metodologías formales a las que consideraban excesivamente “pesadas”
y rígidas por su carácter normativo y fuerte dependencia de
planificaciones detalladas previamente al desarrollo.</p></li>
</ul>
<p>Estamos descubriendo formas mejores de desarrollar software tanto por
nuestra propia experiencia como ayudando a terceros.</p>
<ul>
<li><p>A través de este trabajo hemos aprendido a valorar:</p>
<ul>
<li><p><strong>Individuos e interacciones</strong> sobre procesos y
herramientas.</p></li>
<li><p><strong>Software funcionando</strong> sobre documentación
excesiva.</p></li>
<li><p><strong>Colaboración con el cliente</strong> sobre negociación
contractual.</p></li>
<li><p><strong>Respuesta ante el cambio</strong> sobre seguir un
plan.</p></li>
</ul></li>
</ul>
<p>Esto es, aunque valoramos los elementos de la derecha, valoramos más
los de la izquierda (negrita).</p>
<h3 id="principios">Principios</h3>
<ol type="1">
<li><p>Entregar software funcional con frecuencia, desde un par de
semanas hasta un par de meses, con preferencia por los plazos más
cortos.</p></li>
<li><p>Los empresarios y los desarrolladores deben trabajar juntos a
diario durante todo el proyecto.</p></li>
<li><p>Construya los procesos entorno a personas motivadas. Déles el
entorno y el apoyo que necesitan, y confíe en que harán el
trabajo.</p></li>
<li><p>El método más eficiente y eficaz para transmitir información a un
equipo de desarrollo y dentro de él es la conversación cara a
cara.</p></li>
<li><p>A intervalos regulares, el equipo reflexiona sobre cómo ser más
eficaz, y luego afina y ajusta su comportamiento en
consecuencia.</p></li>
<li><p>El software en funcionamiento es la principal medida de
progreso.</p></li>
<li><p>Los procesos ágiles promueven el desarrollo sostenible. Los
patrocinadores, los desarrolladores y los usuarios deben ser capaces de
mantener un ritmo constante indefinidamente.</p></li>
<li><p>La atención continua a la excelencia técnica y al buen diseño
mejora la agilidad.</p></li>
<li><p>La simplicidad -el arte de maximizar la cantidad de trabajo no
realizado- es esencial.</p></li>
<li><p>Las mejores arquitecturas, requisitos y diseós surgen de equipos
autoorganizados.</p></li>
</ol>
<h1 id="metodologías-ágiles">Metodologías ágiles</h1>
<p>El desarrollo software es un proceso de aprendizaje.</p>
<p>No se completa hasta que el sistema funciona con cierto grado de
capacidad.</p>
<p>A medida que plataformas orientadas a los clientes asquirían tamaños
abrumadores, quedaba cada vez más claro que los enfoques en cascada eran
incompatibles con sus necesidades.</p>
<ul>
<li>Gran capacidad de respuesta.</li>
</ul>
<p>En este nuevo modelo no caben las grandes especificaciones de
requisitos.</p>
<ul>
<li><p>Capturar un requisito, analizarlo y diseñarlo, implementarlo,
probar esa implementación y desplegar el resultado al usuario final.</p>
<ul>
<li>Requirementes backlogs infinitos.</li>
</ul></li>
</ul>
<p>Estos sistemas orientados al usuario integran estrechamente el ciclo
de vida del desarrollo de software con las tareas de operación.</p>
<ul>
<li><p>¿Desconexión del sistema entre actualizaciones?</p></li>
<li><p>Nuevas funcionalidades o cambios entregadas poco a poco.</p></li>
</ul>
<p>Los sistemas a gran escala son complejos e imprevisibles.</p>
<p>Cuando se implementan cambios, estos nunca se entienden del todo
hasta que se desplegan a escala en la base real de usuarios finales.</p>
<ul>
<li>“Probar en producción”: nuevas funcionalidades solo para ciertos
usuarios.</li>
</ul>
<h2 id="el-desafío-devops">El desafío DevOps</h2>
<blockquote>
<p>¿Cuánto tardaría su organización en desplegar un cambio que implique
una sola línea de código? ¿Lo hace de forma repetible y fiable?</p>
</blockquote>
<ul>
<li><p>Poder cambiar una única línea de código, desplegarla y todo esto
de manera continua.</p></li>
<li><p>Teoría Lean/Ágil: desarrolladas como reacción al patrón de
fracasos masivos de software que caracterizó a las Tecnologías de
Información en sus primeros 50 años de existencia.</p></li>
</ul>
<h1 id="devops">DevOps</h1>
<p><img src="/img/2425/tag2/ordinaria/Tema4_1.png" /></p>
<h2 id="organization-and-culture">Organization and culture</h2>
<p>Los equipos de desarrollo y operaciones ya no están “aislados”.</p>
<ul>
<li><p>Ingenieros trabajan en todo el ciclo de vida de la
aplicación.</p>
<ul>
<li><p>Desde el desarrollo y las pruebas hasta la implementación y las
operaciones.</p></li>
<li><p>En algunos modelos de DevOps, los equipos de control de calidad y
de seguridad también se integran.</p></li>
</ul></li>
<li><p>Cambio de cultura y mentalidad.</p>
<ul>
<li>Eliminar las barreras entre dos equipos que anteriormente estaban
aislados.</li>
</ul></li>
</ul>
<p>Ambos equipos colaboran para optimizar la productividad de los
desarrolladores y la confiabilidad de las operaciones.</p>
<h2 id="lean-management">Lean management</h2>
<p>Aplicación de los principios Lean a la gestión del proyecto.</p>
<ol type="1">
<li><p>Definir valor.</p></li>
<li><p>Mapear el flujo de valor.</p></li>
<li><p>Crear el flujo.</p></li>
<li><p>Establecer el sistema “pull”.</p></li>
<li><p>Buscar la perfección.</p></li>
</ol>
<h2 id="prácticas">Prácticas</h2>
<ul>
<li><p><strong>Desarrollo dirigido por tests</strong> (Test-driven
development).</p></li>
<li><p><strong>Refactorización continua</strong> (ongoing
refactoring).</p></li>
<li><p><strong>Integración continua</strong> (Continuous
integration).</p></li>
<li><p><strong>Despliegue continuo</strong> (Continuous
deployment).</p></li>
</ul>
<h3 id="desarrollo-dirigido-por-tests-tdd">Desarrollo dirigido por tests
(TDD)</h3>
<p>Antiguamente, existían los roles de desarrollador y de tester.</p>
<ul>
<li><p>No conocer el código que se testea.</p></li>
<li><p>Código imposible de probar.</p></li>
<li><p>Test inexistentes debido a falta de tiempo.</p></li>
</ul>
<p>Los propios desarrolladores son los que escriben sus tests
unitarios.</p>
<ol type="1">
<li><p><strong>Fase red:</strong> partimos siempre de la fase Red en la
que, a partir de un requisito que describa una funcionalidad,
escribiremos el test o los tests que validarán dicha función.</p></li>
<li><p><strong>Fase green:</strong> una vez que tenemos el test fallido,
implementamos el código más simple que haga pasar este test fallido.
Este código no tiene que ser el más elegante o eficiente.</p></li>
</ol>
<ul>
<li>Volver a red (test que rompa la funcionalidad) o a refactor.</li>
</ul>
<ol start="3" type="1">
<li><strong>Fase refactor:</strong> una vez que hemos escrito una serie
de tests o simplemente un test, entramos en la fase de refactoring en la
que mejoramos el código sin modificar la funcionalidad.</li>
</ol>
<h3 id="integración-continua-ci">Integración continua (CI)</h3>
<p>La integración continua es una práctica de <u>desarrollo de
software</u> mediante la cual los desarrolladores combinan los cambios
en el código en un repositorio central de forma periódica, tras la cual
se ejecutan versiones y pruebas automáticas.</p>
<ol type="1">
<li><p>Los desarrolladores envían los cambios de forma periódica a un
repositorio compartido con un sistema de control de versiones como
Git.</p></li>
<li><p>Antes de cada envío, los desarrolladores pueden elegir ejecutar
pruebas de unidad local en el código como medida de verificación
adicional antes de la integración.</p></li>
<li><p>Un servicio de integración continua crea y ejecuta
automáticamente pruebas de unidad en los nuevos cambios realizados en el
código para identificar inmediatamente cualquier error.</p></li>
</ol>
<ol type="1">
<li><p><strong>Planificación:</strong> ya sea que estemos desarrollando
una funcionalidad nueva, o resolviendo un problema, lo que sea que se
vaya a desarrollar, se planifica. Si bien la etapa es agnóstica a la
metodología, lo normal es que se planifique usando metodologías ágiles o
afines.</p></li>
<li><p><strong>Codificación:</strong> el equipo de desarrollo empieza a
escribir el código que da vida a la funcionalidad o resuelve el problema
encontrado. Aquí se hace uso de herramientas de gestión de código como
Git o similares.</p></li>
<li><p><strong>Build:</strong> el proceso de compilación del código,
donde se ejecutan las herramientas y/o scripts que generan el artefacto
del componente o aplicación.</p></li>
<li><p><strong>Testing:</strong> esta etapa introduce los primeros
chequeos a ejecutar sobre el código desarrollado y sobre la aplicación
desplegada. La idea es hacer pruebas sencillas que descarten problemas
“evidentes”.</p></li>
</ol>
<h3 id="despliegue-continuo-cd">Despliegue continuo (CD)</h3>
<p>Comienza luego de que la etapa de integración finaliza.</p>
<ul>
<li><p>Esto da lugar a:</p>
<ul>
<li><p>Las tareas esenciales para asegurar la calidad del código o del
artefacto generado.</p></li>
<li><p>Tareas que involucran el despliegue y entrega final</p></li>
</ul></li>
</ul>
<p>El final de esta fase acaba en un contenedor o servidor donde se
quiere implementar el código o artefacto de la aplicación.</p>
<ol type="1">
<li><p><strong>Release:</strong> en esta etapa se efectuarán todas las
áreas relacionadas con la liberación. Además, se configuran las bases
necesarias para poder desplegar el código o artefacto.</p></li>
<li><p><strong>Despliegue:</strong> el código se traslada a producción.
Aunque a veces, primero se despliega en un entorno replica de producción
llamado “staging”, el cual sirve para hacer las validaciones finales y
funciones del despliegue.</p></li>
<li><p><strong>Operaciones:</strong> en esta etapa se monitorea y se
mide el estado de salud y rendimiento del despliegue. Un buen sistema de
monitoreo nos permite anticiparnos a los problemas y aprender de
ellos.</p></li>
</ol>
<h2 id="ciclo-devops-ci-y-cd">Ciclo DevOps (CI y CD)</h2>
<p><img src="/img/2425/tag2/ordinaria/Tema4_1.png" /></p>
</body>
</html>
